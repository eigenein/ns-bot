#!/usr/bin/env python3
# coding: utf-8

"""
What can this bot do?

The bot can plan a trip with NS trains via their recommendations service.
"""

import asyncio
import collections
import contextlib
import difflib
import enum
import json
import logging
import typing

from xml.etree import ElementTree

import aiohttp
import aioredis
import click


# CLI Commands.
# ----------------------------------------------------------------------------------------------------------------------

@click.command()
@click.option("-c", "--config", "config_file", type=click.File("rt", encoding="utf-8"), help="Configuration file.", required=True)
@click.option("-l", "--log-file", type=click.File("at", encoding="utf-8"))
@click.option("-v", "--verbose", type=bool, is_flag=True)
def main(config_file: click.File, log_file: click.File, verbose: bool):
    logging.basicConfig(
        datefmt="%Y-%m-%d %H:%M:%S",
        format="%(asctime)s (%(module)s) [%(levelname)s] %(message)s",
        level=(logging.INFO if not verbose else logging.DEBUG),
        stream=(log_file or click.get_text_stream("stderr")),
    )

    logging.info("Reading configuration…")
    config = json.load(config_file)

    logging.info("Starting bot…")
    with contextlib.closing(Telegram(config["telegram_token"])) as telegram:
        with contextlib.closing(Botan(config["botan_token"])) as botan:
            with contextlib.closing(Ns(config["ns_api"]["login"], config["ns_api"]["password"])) as ns:
                with contextlib.closing(Bot(telegram, botan, ns)) as bot:
                    try:
                        asyncio.ensure_future(bot.run())
                        asyncio.get_event_loop().run_forever()
                    finally:
                        bot.stop()
                        # TODO: graceful stop finishing all the pending tasks.


# Emoji.
# ----------------------------------------------------------------------------------------------------------------------

class Emoji:
    BLACK_SUN_WITH_RAYS = chr(0x2600)
    PENSIVE_FACE = chr(0x1F614)
    TRAIN = chr(0x1F686)
    WHITE_QUESTION_MARK_ORNAMENT = chr(0x2754)


# Bot response phrases.
# ----------------------------------------------------------------------------------------------------------------------

class Responses:
    START = (
        "*Hi {{sender[first_name]}}!* {emoji.BLACK_SUN_WITH_RAYS}\n"
        "\n"
        "You can add your favorite station simply by sending me its name. Small typos are okay.\n"
        "\n"
        "You can also send me your location to see departures from the nearest station."
    ).format(emoji=Emoji)

    ERROR = (
        "I’m experiencing some technical problems, sorry. {emoji.PENSIVE_FACE}\n"
        "\n"
        "Maybe try again later."
    ).format(emoji=Emoji)

    DEFAULT = "Hi {sender[first_name]}! Tap a departure station to plan a trip."
    ADDED = "It’s added! Now you can use it as either departure or destination. Add as many stations as you would like to use."
    DELETED = "It’s deleted. You can always add it back later."
    SEARCH = "Just send me a station name. You can do that whenever you want."
    NO_SEARCH_RESULTS = "I couldn’t find any station with similar name. Please check it and try again."
    SEARCH_RESULTS = "I’ve found the following stations. Tap a station to add it to favorites."
    SELECT_DESTINATION = "Ok, where would you like to go?"


# Redis wrapper.
# ----------------------------------------------------------------------------------------------------------------------

class Database:
    @staticmethod
    async def create():
        return Database(await aioredis.create_redis(("localhost", 6379)))

    def __init__(self, connection: aioredis.Redis):
        self.connection = connection

    async def add_favorite_station(self, user_id: int, station_code: str):
        await self.connection.sadd("ns:%s:favorites" % user_id, station_code)

    async def get_favorites_stations(self, user_id: int) -> typing.Iterable[str]:
        """
        Gets the codes of the user's favorite stations.
        """
        return await self.connection.smembers("ns:%s:favorites" % user_id, encoding="utf-8")

    async def delete_favorite_station(self, user_id, station_code: str):
        await self.connection.srem("ns:%s:favorites" % user_id, station_code)

    def close(self):
        self.connection.close()


# Telegram API.
# ----------------------------------------------------------------------------------------------------------------------

class ParseMode(enum.Enum):
    """
    Telegram message parse mode.
    """
    default = None
    markdown = "Markdown"
    html = "HTML"


class ChatAction(enum.Enum):
    """
    https://core.telegram.org/bots/api#sendchataction
    """
    typing = "typing"
    upload_photo = "upload_photo"
    record_video = "record_video"
    upload_video = "upload_video"
    record_audio = "record_audio"
    upload_audio = "upload_audio"
    upload_document = "upload_document"
    find_location = "find_location"


class Telegram:

    HEADERS = {"Content-Type": "application/json"}

    def __init__(self, token: str):
        self._url = "https://api.telegram.org/bot{}/{{}}".format(token)
        self.session = aiohttp.ClientSession()

    async def get_updates(self, offset: int, limit: int, timeout: int):
        return await self.post("getUpdates", offset=offset, limit=limit, timeout=timeout)

    async def send_message(
        self,
        chat_id: typing.Union[int, str],
        text: str,
        parse_mode=ParseMode.default,
        disable_web_page_preview=False,
        reply_to_message_id=None,
        reply_markup=None,
    ):
        params = {"chat_id": chat_id, "text": text}
        if parse_mode != ParseMode.default:
            params["parse_mode"] = parse_mode.value
        if disable_web_page_preview:
            params["disable_web_page_preview"] = disable_web_page_preview
        if reply_to_message_id is not None:
            params["reply_to_message_id"] = reply_to_message_id
        if reply_markup is not None:
            params["reply_markup"] = reply_markup
        return await self.post("sendMessage", **params)

    async def send_chat_action(self, chat_id: typing.Union[int, str], action: ChatAction):
        """
        https://core.telegram.org/bots/api#sendchataction
        """
        return await self.post("sendChatAction", chat_id=chat_id, action=action.value)

    async def answer_callback_query(self, callback_query_id: str, text=None, show_alert=False):
        """
        https://core.telegram.org/bots/api#answercallbackquery
        """
        params = {"callback_query_id": callback_query_id}
        if text:
            params["text"] = text
        if show_alert:
            params["show_alert"] = show_alert
        return await self.post("answerCallbackQuery", **params)

    async def post(self, method: str, **kwargs):
        logging.debug("%s(%s)", method, kwargs)
        async with self.session.post(self._url.format(method), data=json.dumps(kwargs), headers=self.HEADERS) as response:
            payload = await response.json()
            if payload["ok"]:
                logging.debug("%s → %s", method, payload)
                return payload["result"]
            else:
                logging.error("%s → %s", method, payload)
                raise TelegramException(payload["description"])

    def close(self):
        self.session.close()


class TelegramException(Exception):

    def __init__(self, message):
        super().__init__(message)


# Bot Analytics.
# ----------------------------------------------------------------------------------------------------------------------

class Botan:
    """
    Botan.io API.
    """

    HEADERS = {"Content-Type": "application/json"}

    def __init__(self, token: str):
        self.token = token
        self.session = aiohttp.ClientSession()

    async def track(self, uid: typing.Optional[str], name: str, **kwargs):
        """
        Tracks event.
        """
        try:
            async with self.session.post(
                "https://api.botan.io/track",
                params={"token": self.token, "uid": uid, "name": name},
                data=json.dumps(kwargs),
                headers=self.HEADERS,
            ) as response:
                payload = await response.json()
                if payload["status"] == "failed":
                    logging.error("Failed to track event: %s", payload.get("info"))
        except Exception as ex:
            logging.error("Failed to track event.", exc_info=ex)

    def close(self):
        self.session.close()


# NS API.
# ----------------------------------------------------------------------------------------------------------------------

class Ns:
    Station = collections.namedtuple("Station", "code long_name names lat lon")

    def __init__(self, login: str, password: str):
        self.session = aiohttp.ClientSession(auth=aiohttp.BasicAuth(login=login, password=password))

    async def get_stations(self):
        """
        Gets station list.
        """
        stations = []
        async with self.session.get("http://webservices.ns.nl/ns-api-stations-v2") as response:
            stations_element = ElementTree.fromstring(await response.text())
            for station_element in stations_element:
                names = {element.text for element in station_element.find("Namen")}
                names.update(element.text for element in station_element.find("Synoniemen"))
                stations.append(Ns.Station(
                    code=station_element.find("Code").text,
                    long_name=station_element.find("Namen").find("Lang").text,
                    names=names,
                    lat=station_element.find("Lat").text,
                    lon=station_element.find("Lon").text,
                ))
        return stations

    def close(self):
        self.session.close()


# Station index.
# ----------------------------------------------------------------------------------------------------------------------

class StationIndex:
    def __init__(self, stations: typing.Iterable[Ns.Station]):
        self.code_station = {
            station.code: station
            for station in stations
        }  # type: typing.Dict[str, Ns.Station]
        self.name_station = {
            name.lower(): station
            for station in stations
            for name in station.names
        }  # type: typing.Dict[str, Ns.Station]
        self.names = list(self.name_station)

    def search(self, query: str) -> typing.List[Ns.Station]:
        """
        Searches for unique stations that match the query.
        """
        logging.debug("Query: %s", query)
        return [
            self.code_station[code]
            for code in collections.OrderedDict.fromkeys(
                self.name_station[name].code
                for name in difflib.get_close_matches(query.lower(), self.names)
            )
        ]


# Bot implementation.
# ----------------------------------------------------------------------------------------------------------------------

class Bot:
    LIMIT = 100
    TIMEOUT = 60

    KEY_CANCEL = {"text": "Cancel", "callback_data": "/cancel"}
    KEY_SEARCH = {"text": "Search Station", "callback_data": "/search"}
    KEY_DEPARTURES = {"text": "Departures", "callback_data": "/departures"}
    KEY_CONTACT = {"text": "Bot Feedback", "url": "https://telegram.me/eigenein"}

    TRANSLATE_TABLE = {
        ord("а"): "a", ord("б"): "b", ord("в"): "v", ord("г"): "g", ord("д"): "d", ord("е"): "e", ord("ж"): "zh",
        ord("з"): "z", ord("и"): "i", ord("й"): "i", ord("к"): "k", ord("л"): "l", ord("м"): "m", ord("н"): "n",
        ord("о"): "o", ord("п"): "p", ord("р"): "r", ord("с"): "c", ord("т"): "t", ord("у"): "u", ord("ф"): "f",
        ord("х"): "h", ord("ц"): "c", ord("ч"): "ch", ord("ш"): "sch", ord("щ"): "shch", ord("ъ"): "", ord("ь"): "",
        ord("э"): "e", ord("ю"): "u", ord("я"): "ya",
    }

    def __init__(self, telegram: Telegram, botan: Botan, ns: Ns):
        self.telegram = telegram
        self.botan = botan
        self.ns = ns
        self.db = None  # type: Database
        self.stations = None  # type: StationIndex
        self.offset = 0
        self.is_stopped = False

    async def run(self):
        self.db = await Database.create()

        logging.info("Pre-populating station list…")
        stations = await self.ns.get_stations()
        logging.info("Retrieved %d stations.", len(stations))
        self.stations = StationIndex(stations)

        logging.info("Running.")
        while not self.is_stopped:
            try:
                await self.run_loop()
            except Exception as ex:
                logging.error("Unhandled error.", exc_info=ex)
                await self.botan.track(None, "Error", message=str(ex))

    def stop(self):
        self.is_stopped = True

    def close(self):
        self.db.close()

    async def run_loop(self):
        """
        Executes one message loop iteration. Gets Telegram updates and handles them.
        """
        updates = await self.telegram.get_updates(self.offset, self.LIMIT, self.TIMEOUT)
        for update in updates:
            logging.info("Got update #%s.", update["update_id"])
            self.offset = update["update_id"] + 1
            # Merge message text and callback query data.
            if "message" in update:
                sender, text, location = update["message"]["from"], update["message"]["text"], update["message"].get("location")
            elif "callback_query" in update:
                sender, text, location = update["callback_query"]["from"], update["callback_query"]["data"], None
            else:
                continue
            try:
                await self.handle_message(sender, text, location)
                if "callback_query" in update:
                    await self.telegram.answer_callback_query(update["callback_query"]["id"])
            except Exception:
                await self.telegram.send_message(
                    sender["id"],
                    Responses.ERROR,
                    reply_markup=(await self.get_default_keyboard(sender["id"])),
                )
                raise

    async def get_default_keyboard(self, user_id: int) -> str:
        station_codes = await self.db.get_favorites_stations(user_id)
        buttons = [
            [{"text": self.stations.code_station[station_code].long_name, "callback_data": "/go %s" % station_code}]
            for station_code in station_codes
        ]
        buttons.extend([[self.KEY_SEARCH, self.KEY_CONTACT]])
        return json.dumps({"inline_keyboard": buttons})

    async def handle_message(self, sender: dict, text: str, location: dict):
        """
        Handle single message from a user.
        """
        if text.startswith("/"):
            command, *arguments = text.split()
            if command == "/start":
                await self.handle_start(sender)
            elif command == "/search":
                await self.handle_search(sender)
            elif command == "/cancel":
                await self.handle_cancel(sender)
            elif command == "/add":
                await self.handle_add(sender, arguments)
            elif command == "/delete":
                if arguments:
                    await self.handle_delete(sender, arguments[0])
            elif command == "/go":
                if len(arguments) == 1:
                    await self.handle_go_from(sender, arguments[0])
                elif len(arguments) == 2:
                    await self.handle_go_from_to(sender, arguments[0], arguments[1])
            # TODO: handle location: show departures, add to favs, show destinations.
        else:
            await self.handle_search_query(sender, text)

    async def handle_start(self, sender: dict):
        """
        Handles /start command.
        """
        await self.telegram.send_message(
            sender["id"],
            Responses.START.format(sender=sender),
            parse_mode=ParseMode.markdown,
            reply_markup=(await self.get_default_keyboard(sender["id"])),
        )
        await self.botan.track(sender["id"], "Start")

    async def handle_cancel(self, sender: dict):
        """
        Handles /cancel command.
        """
        await self.telegram.send_message(
            sender["id"],
            Responses.DEFAULT.format(sender=sender),
            reply_markup=(await self.get_default_keyboard(sender["id"])),
        )
        await self.botan.track(sender["id"], "Cancel")

    async def handle_search(self, sender: dict):
        """
        Handles /search command.
        """
        await self.telegram.send_message(
            sender["id"],
            Responses.SEARCH,
            reply_markup=(await self.get_default_keyboard(sender["id"])),
        )
        await self.botan.track(sender["id"], "Search")

    async def handle_add(self, sender: dict, station_codes: typing.Iterable[str]):
        """
        Handles /add command.
        """
        for station_code in station_codes:
            await self.db.add_favorite_station(sender["id"], station_code)
            await self.botan.track(sender["id"], "Add", station_code=station_code)
        await self.telegram.send_message(
            sender["id"],
            Responses.ADDED,
            reply_markup=(await self.get_default_keyboard(sender["id"])),
        )

    async def handle_delete(self, sender: dict, station_code: str):
        """
        Handles /delete command.
        """
        await self.db.delete_favorite_station(sender["id"], station_code)
        await self.botan.track(sender["id"], "Delete", station_code=station_code)

        await self.telegram.send_message(
            sender["id"],
            Responses.DELETED,
            reply_markup=(await self.get_default_keyboard(sender["id"])),
        )

    async def handle_go_from(self, sender: dict, departure_code: str):
        """
        Handles /go command with one argument provided.
        """
        station_codes = await self.db.get_favorites_stations(sender["id"])
        buttons = [
            [{
                "text": self.stations.code_station[destination_code].long_name,
                "callback_data": "/go %s %s" % (departure_code, destination_code),
            }]
            for destination_code in station_codes
            if destination_code != departure_code
        ]
        buttons.append([{"text": "Delete station", "callback_data": "/delete %s" % departure_code}, self.KEY_CANCEL])
        await self.telegram.send_message(
            sender["id"],
            Responses.SELECT_DESTINATION,
            reply_markup=json.dumps({"inline_keyboard": buttons}),
        )
        await self.botan.track(sender["id"], "From", station_code=departure_code)

    async def handle_go_from_to(self, sender: dict, departure_code: str, arrival_code: str):
        """
        Handles /go command with two arguments provided.
        """
        # TODO: plan a trip.
        # TODO: add to favorite trips.

    async def handle_search_query(self, sender: dict, text: str):
        """
        Handles station search.
        """
        logging.debug("Search: %s", text)
        stations = self.stations.search(text.strip().translate(self.TRANSLATE_TABLE))
        if stations:
            buttons = [
                [{"text": station.long_name, "callback_data": "/add %s" % station.code}]
                for station in stations
            ]
            buttons.append([self.KEY_CANCEL])
            await self.telegram.send_message(
                sender["id"],
                Responses.SEARCH_RESULTS,
                reply_markup=json.dumps({"inline_keyboard": buttons}),
            )
        else:
            await self.telegram.send_message(
                sender["id"],
                Responses.NO_SEARCH_RESULTS,
                reply_markup=(await self.get_default_keyboard(sender["id"])),
            )
        await self.botan.track(sender["id"], "Query", query=text)


# Entry point.
# ----------------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
    main()
