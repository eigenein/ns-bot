#!/usr/bin/env python3
# coding: utf-8

"""
What can this bot do?

The bot can plan a trip with NS trains via their recommendations service.
"""

import asyncio
import contextlib
import enum
import json
import logging
import typing

import aiohttp
import aioredis
import click


# CLI Commands.
# ----------------------------------------------------------------------------------------------------------------------

@click.command()
@click.option("-c", "--config", "config_file", type=click.File("rt", encoding="utf-8"), help="Configuration file.", required=True)
@click.option("-l", "--log-file", type=click.File("at", encoding="utf-8"))
@click.option("-v", "--verbose", type=bool, is_flag=True)
def main(config_file: click.File, log_file: click.File, verbose: bool):
    logging.basicConfig(
        datefmt="%Y-%m-%d %H:%M:%S",
        format="%(asctime)s (%(module)s) [%(levelname)s] %(message)s",
        level=(logging.INFO if not verbose else logging.DEBUG),
        stream=(log_file or click.get_text_stream("stderr")),
    )

    logging.info("Reading configuration…")
    config = json.load(config_file)

    logging.info("Starting bot…")
    with contextlib.closing(Telegram(config["telegram_token"])) as telegram:
        with contextlib.closing(Botan(config["botan_token"])) as botan:
            with contextlib.closing(Ns(config["ns_api"]["login"], config["ns_api"]["password"])) as ns:
                with contextlib.closing(Bot(telegram, botan, ns)) as bot:
                    try:
                        asyncio.ensure_future(bot.run())
                        asyncio.get_event_loop().run_forever()
                    finally:
                        bot.stop()
                        # TODO: graceful stop.


# Emoji.
# ----------------------------------------------------------------------------------------------------------------------

class Emoji:
    BLACK_SUN_WITH_RAYS = chr(0x2600)
    PENSIVE_FACE = chr(0x1F614)


# Bot response phrases.
# ----------------------------------------------------------------------------------------------------------------------

class Responses:
    START = (
        "*Hi {{sender[first_name]}}!* {emoji.BLACK_SUN_WITH_RAYS}\n"
        "\n"
        "To get started please send me your favorite stations, one per line. Don’t worry, you can change them later."
    ).format(emoji=Emoji)

    ERROR = (
        "I’m experiencing some technical problems, sorry. {emoji.PENSIVE_FACE}\n"
        "\n"
        "Maybe try again later."
    ).format(emoji=Emoji)


# Redis wrapper.
# ----------------------------------------------------------------------------------------------------------------------

class Database:
    @staticmethod
    async def create():
        return Database(await aioredis.create_redis(("localhost", 6379)))

    def __init__(self, connection: aioredis.Redis):
        self.connection = connection

    def close(self):
        self.connection.close()


# Telegram API.
# ----------------------------------------------------------------------------------------------------------------------

class ParseMode(enum.Enum):
    """
    Telegram message parse mode.
    """
    default = None
    markdown = "Markdown"
    html = "HTML"


class ChatAction(enum.Enum):
    """
    https://core.telegram.org/bots/api#sendchataction
    """
    typing = "typing"
    upload_photo = "upload_photo"
    record_video = "record_video"
    upload_video = "upload_video"
    record_audio = "record_audio"
    upload_audio = "upload_audio"
    upload_document = "upload_document"
    find_location = "find_location"


class Telegram:

    HEADERS = {"Content-Type": "application/json"}

    def __init__(self, token: str):
        self._url = "https://api.telegram.org/bot{}/{{}}".format(token)
        self.session = aiohttp.ClientSession()

    async def get_updates(self, offset: int, limit: int, timeout: int):
        return await self.post("getUpdates", offset=offset, limit=limit, timeout=timeout)

    async def send_message(
        self,
        chat_id: typing.Union[int, str],
        text: str,
        parse_mode=ParseMode.default,
        disable_web_page_preview=False,
        reply_to_message_id=None,
        reply_markup=None,
    ):
        params = {"chat_id": chat_id, "text": text}
        if parse_mode != ParseMode.default:
            params["parse_mode"] = parse_mode.value
        if disable_web_page_preview:
            params["disable_web_page_preview"] = disable_web_page_preview
        if reply_to_message_id is not None:
            params["reply_to_message_id"] = reply_to_message_id
        if reply_markup is not None:
            params["reply_markup"] = reply_markup
        return await self.post("sendMessage", **params)

    async def send_chat_action(self, chat_id: typing.Union[int, str], action: ChatAction):
        """
        https://core.telegram.org/bots/api#sendchataction
        """
        return await self.post("sendChatAction", chat_id=chat_id, action=action.value)

    async def post(self, method: str, **kwargs):
        logging.debug("%s(%s)", method, kwargs)
        async with self.session.post(self._url.format(method), data=json.dumps(kwargs), headers=self.HEADERS) as response:
            payload = await response.json()
            if payload["ok"]:
                logging.debug("%s → %s", method, payload)
                return payload["result"]
            else:
                logging.error("%s → %s", method, payload)
                raise TelegramException(payload["description"])

    def close(self):
        self.session.close()


class TelegramException(Exception):

    def __init__(self, message):
        super().__init__(message)


# Bot Analytics.
# ----------------------------------------------------------------------------------------------------------------------

class Botan:
    """
    Botan.io API.
    """

    HEADERS = {"Content-Type": "application/json"}

    def __init__(self, token: str):
        self.token = token
        self.session = aiohttp.ClientSession()

    async def track(self, uid: typing.Optional[str], name: str, **kwargs):
        """
        Tracks event.
        """
        try:
            async with self.session.post(
                "https://api.botan.io/track",
                params={"token": self.token, "uid": uid, "name": name},
                data=json.dumps(kwargs),
                headers=self.HEADERS,
            ) as response:
                payload = await response.json()
                if payload["status"] == "failed":
                    logging.error("Failed to track event: %s", payload.get("info"))
        except Exception as ex:
            logging.error("Failed to track event.", exc_info=ex)

    def close(self):
        self.session.close()


# NS API.
# ----------------------------------------------------------------------------------------------------------------------

class Ns:
    def __init__(self, login: str, password: str):
        self.session = aiohttp.ClientSession(auth=aiohttp.BasicAuth(login=login, password=password))

    async def get_stations(self):
        """
        Gets station list.
        """
        async with self.session.get("http://webservices.ns.nl/ns-api-stations-v2") as response:
            pass

    def close(self):
        self.session.close()


# Bot implementation.
# ----------------------------------------------------------------------------------------------------------------------

class Bot:
    LIMIT = 10
    TIMEOUT = 10

    def __init__(self, telegram: Telegram, botan: Botan, ns: Ns):
        self.telegram = telegram
        self.botan = botan
        self.ns = ns
        self.db = None  # type: Database
        self.offset = 0
        self.is_stopped = False

    async def run(self):
        self.db = await Database.create()

        logging.info("Pre-populating station list…")
        await self.ns.get_stations()

        logging.info("Running.")
        while not self.is_stopped:
            try:
                await self.run_loop()
            except Exception as ex:
                logging.error("Unhandled error.", exc_info=ex)
                await self.botan.track(None, "Error", message=str(ex))

    def stop(self):
        self.is_stopped = True

    def close(self):
        self.db.close()

    async def run_loop(self):
        """
        Executes one message loop iteration. Gets Telegram updates and handles them.
        """
        updates = await self.telegram.get_updates(self.offset, self.LIMIT, self.TIMEOUT)
        for update in updates:
            logging.info("Got update #%s.", update["update_id"])
            self.offset = update["update_id"] + 1
            # Merge message text and callback query data.
            if "message" in update:
                sender, text = update["message"]["from"], update["message"]["text"]
            elif "callback_query" in update:
                sender, text = update["callback_query"]["from"], update["callback_query"]["data"]
            else:
                continue
            try:
                await self.handle_message(sender, text)
            except Exception:
                await self.telegram.send_message(sender["id"], Responses.ERROR)
                raise

    async def handle_message(self, sender: dict, text: str):
        """
        Handle single message from a user.
        """
        if text.startswith("/"):
            command, *arguments = text.split()
            if command == "/start":
                await self.handle_start(sender)
                await self.botan.track(sender["id"], "Start")
            elif command == "/cancel":
                await self.handle_cancel(sender)
                await self.botan.track(sender["id"], "Cancel")
        else:
            await self.handle_search(sender, text)
            await self.botan.track(sender["id"], "Search")

    async def handle_start(self, sender: dict):
        """
        Handles /start command.
        """
        await self.telegram.send_message(
            sender["id"],
            Responses.START.format(sender=sender),
            parse_mode=ParseMode.markdown,
        )

    async def handle_cancel(self, sender: dict):
        """
        Handles /cancel command.
        """
        pass  # TODO

    async def handle_search(self, sender: dict, text: str):
        """
        Handles stations search.
        """
        pass  # TODO


# Entry point.
# ----------------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
    main()
